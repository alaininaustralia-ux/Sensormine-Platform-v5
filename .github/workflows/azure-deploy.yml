name: Azure Infrastructure Deployment

on:
  push:
    branches: [master, main]
    paths:
      - 'infrastructure/terraform/**'
      - '.github/workflows/azure-deploy.yml'
  pull_request:
    branches: [master, main]
    paths:
      - 'infrastructure/terraform/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod

env:
  ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
  ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
  TF_VERSION: '1.6.0'

jobs:
  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'dev' }}
    outputs:
      tfplanExitCode: ${{ steps.plan.outputs.exitcode }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: |
            {
              "clientId": "${{ secrets.AZURE_CLIENT_ID }}",
              "clientSecret": "${{ secrets.AZURE_CLIENT_SECRET }}",
              "subscriptionId": "${{ secrets.AZURE_SUBSCRIPTION_ID }}",
              "tenantId": "${{ secrets.AZURE_TENANT_ID }}"
            }

      - name: Terraform Init
        working-directory: infrastructure/terraform/azure
        run: |
          terraform init \
            -backend-config="resource_group_name=${{ secrets.TF_STATE_RG }}" \
            -backend-config="storage_account_name=${{ secrets.TF_STATE_STORAGE }}" \
            -backend-config="container_name=tfstate" \
            -backend-config="key=sensormine-${{ github.event.inputs.environment || 'dev' }}.terraform.tfstate"

      - name: Terraform Format Check
        working-directory: infrastructure/terraform/azure
        run: terraform fmt -check -recursive
        continue-on-error: true

      - name: Terraform Validate
        working-directory: infrastructure/terraform/azure
        run: terraform validate

      - name: Terraform Plan
        id: plan
        working-directory: infrastructure/terraform/azure
        run: |
          terraform plan \
            -var-file="environments/${{ github.event.inputs.environment || 'dev' }}.tfvars" \
            -var="db_admin_password=${{ secrets.DB_ADMIN_PASSWORD }}" \
            -out=tfplan \
            -detailed-exitcode
        continue-on-error: true

      - name: Upload Terraform Plan
        uses: actions/upload-artifact@v4
        with:
          name: tfplan-${{ github.event.inputs.environment || 'dev' }}
          path: infrastructure/terraform/azure/tfplan

      - name: Comment PR with Plan
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const output = `#### Terraform Plan ðŸ“–
            **Environment:** \`${{ github.event.inputs.environment || 'dev' }}\`
            **Plan Exit Code:** \`${{ steps.plan.outputs.exitcode }}\`
            
            <details><summary>Show Plan</summary>
            
            \`\`\`terraform
            ${{ steps.plan.outputs.stdout }}
            \`\`\`
            
            </details>
            
            *Pusher: @${{ github.actor }}, Action: \`${{ github.event_name }}\`*`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            });

  terraform-apply:
    name: Terraform Apply
    needs: terraform-plan
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'dev' }}
    if: |
      (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch') &&
      needs.terraform-plan.outputs.tfplanExitCode == '2'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: |
            {
              "clientId": "${{ secrets.AZURE_CLIENT_ID }}",
              "clientSecret": "${{ secrets.AZURE_CLIENT_SECRET }}",
              "subscriptionId": "${{ secrets.AZURE_SUBSCRIPTION_ID }}",
              "tenantId": "${{ secrets.AZURE_TENANT_ID }}"
            }

      - name: Terraform Init
        working-directory: infrastructure/terraform/azure
        run: |
          terraform init \
            -backend-config="resource_group_name=${{ secrets.TF_STATE_RG }}" \
            -backend-config="storage_account_name=${{ secrets.TF_STATE_STORAGE }}" \
            -backend-config="container_name=tfstate" \
            -backend-config="key=sensormine-${{ github.event.inputs.environment || 'dev' }}.terraform.tfstate"

      - name: Download Terraform Plan
        uses: actions/download-artifact@v4
        with:
          name: tfplan-${{ github.event.inputs.environment || 'dev' }}
          path: infrastructure/terraform/azure

      - name: Terraform Apply
        working-directory: infrastructure/terraform/azure
        run: terraform apply -auto-approve tfplan

      - name: Get AKS Credentials
        run: |
          az aks get-credentials \
            --resource-group rg-sensormine-${{ github.event.inputs.environment || 'dev' }}-eastus \
            --name aks-sensormine-${{ github.event.inputs.environment || 'dev' }}-eastus \
            --overwrite-existing

      - name: Deploy to AKS
        run: |
          # Install Helm if not present
          curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
          
          # Deploy the Sensormine Helm chart
          helm upgrade --install sensormine ./infrastructure/helm/sensormine-platform \
            --namespace sensormine \
            --create-namespace \
            --set environment=${{ github.event.inputs.environment || 'dev' }} \
            --wait

  docker-build-push:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    needs: terraform-apply
    if: |
      (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
    strategy:
      matrix:
        service:
          - ApiGateway
          - Device.API
          - Query.API
          - Ingestion.Service
          - Alerts.API
          - DigitalTwin.API
          - SchemaRegistry.API
          - Edge.Gateway
          - StreamProcessing.Service
          - VideoMetadata.API
          - Billing.API
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: |
            {
              "clientId": "${{ secrets.AZURE_CLIENT_ID }}",
              "clientSecret": "${{ secrets.AZURE_CLIENT_SECRET }}",
              "subscriptionId": "${{ secrets.AZURE_SUBSCRIPTION_ID }}",
              "tenantId": "${{ secrets.AZURE_TENANT_ID }}"
            }

      - name: Login to ACR
        run: |
          az acr login --name acrsensormine${{ github.event.inputs.environment || 'dev' }}eastus

      - name: Build and Push Docker Image
        working-directory: src/Services/${{ matrix.service }}
        run: |
          SERVICE_LOWER=$(echo "${{ matrix.service }}" | tr '[:upper:]' '[:lower:]' | tr '.' '-')
          docker build -t acrsensormine${{ github.event.inputs.environment || 'dev' }}eastus.azurecr.io/sensormine/$SERVICE_LOWER:${{ github.sha }} .
          docker build -t acrsensormine${{ github.event.inputs.environment || 'dev' }}eastus.azurecr.io/sensormine/$SERVICE_LOWER:latest .
          docker push acrsensormine${{ github.event.inputs.environment || 'dev' }}eastus.azurecr.io/sensormine/$SERVICE_LOWER:${{ github.sha }}
          docker push acrsensormine${{ github.event.inputs.environment || 'dev' }}eastus.azurecr.io/sensormine/$SERVICE_LOWER:latest

  deploy-frontend:
    name: Deploy Frontend to Azure Static Web Apps
    runs-on: ubuntu-latest
    needs: terraform-apply
    if: |
      (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/main' || github.event_name == 'workflow_dispatch')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: src/Web/sensormine-web/package-lock.json

      - name: Install dependencies
        working-directory: src/Web/sensormine-web
        run: npm ci

      - name: Build frontend
        working-directory: src/Web/sensormine-web
        env:
          NEXT_PUBLIC_API_URL: ${{ secrets.API_GATEWAY_URL }}
        run: npm run build

      - name: Deploy to Azure Static Web Apps
        uses: Azure/static-web-apps-deploy@v1
        with:
          azure_static_web_apps_api_token: ${{ secrets.AZURE_STATIC_WEB_APPS_API_TOKEN }}
          repo_token: ${{ secrets.GITHUB_TOKEN }}
          action: 'upload'
          app_location: 'src/Web/sensormine-web'
          output_location: '.next'
